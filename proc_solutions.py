#!/usr/bin/env python3
""" Process Google Python class exercises

Check the solutions run correctly:

    python tools/proc_solutions.py check

Write the exercise files from the solutions:

    python tools/proc_solutions.py write

Script assumes directory structure:

    exercise_name/an_exercise.py  <- generated by "write"
                 /another_exercise.py  <- generated by "write"
                 /solution/an_exercise.py
                 /solution/another_exercise.py
                 /solution/another_exercise.params

"another_exercise.params" is a Python syntax file with a single expression
returning a list of parameters to pass when running ``another_exercise.py``
from the ``exercise_name`` directory.  The script uses these for the "check"
action.  For example, imagine ``another_exercise.params`` contains this::

    # Default parameters for running "another_exercise.py"
    ['some_file.txt']

Then the resulting test with "check" will run the equivalent of::

    cd exercise_name
    python solution/another_exercise.py some_file.txt

Use a list of lists in the parameter file to run more than one check::

    # Default parameters for running "another_exercise.py" twice
    ['some_file.txt', 'another_file.txt']

That results in the equivalent of::

    cd exercise_name
    python solution/another_exercise.py some_file.txt
    python solution/another_exercise.py another_file.txt

***********
Definitions
***********

An exercise is a Python script that runs from a particular directory.

The directory from which the script should be executed is the "exercise
directory".  This is the directory below the directory containing
the solution.
"""
# Copyright 2016 Matthew Brett
# Licensed under the 2-clause BSD license.  See LICENSE file.

from __future__ import print_function

import os
import sys
import re
from glob import glob
from os.path import (join as pjoin, dirname, basename, isfile, realpath,
                     splitext)
from subprocess import check_call
from copy import deepcopy
import argparse

STRING_TYPE = str if sys.version_info[0] > 2 else basestring

import pytoml as toml

TOML_FNAMES = ('solution.toml', 'solutions.toml', '.solution.toml',
               '.solutions.toml')
SOLUTION_DIRNAMES = ('solution', 'solutions')


def _get_config(solution_dir):
    config = {'solution_dir': realpath(solution_dir),
              'solution': {}}
    for fname in TOML_FNAMES:
        toml_fname = pjoin(solution_dir, fname)
        if not isfile(toml_fname):
            continue
        with open(toml_fname, 'rt') as conffile:
            config.update(toml.loads(conffile.read()))
        break
    return config


def format_values(value, namespace):
    if hasattr(value, 'keys'):
        return dict([(k, format_values(v, namespace))
                     for k, v in value.items()])
    if isinstance(value, list):
        return [format_values(v, namespace) for v in value]
    if isinstance(value, STRING_TYPE):
        return value.format(**namespace)
    return value


def process_config(config):
    # Fill in solution defaults
    config = deepcopy(config)
    soln_dir = config['solution_dir']
    auto_check = config.get('auto_check', False)
    one_down = realpath(pjoin(soln_dir, '..'))
    namespace = {'sys_exe': sys.executable,
                 'solution_dir': soln_dir,
                 'one_down': one_down}
    for name, info in config['solution'].items():
        base = name + '.py'
        in_path = realpath(pjoin(soln_dir, base))
        info['in_path'] = in_path
        if not 'out_path' in info:
            info['out_path'] = pjoin(one_down, base)
        out_dir = dirname(info['out_path'])
        if not 'checks' in info:
            info['checks'] =  ([{'command': ['{sys_exe}', '{in_path}']}]
                               if auto_check else [])
        for check in info['checks']:
            if not 'cwd' in check:
                check['cwd'] = out_dir
        namespace['in_path'] = in_path
        config['solution'][name] = format_values(info, namespace)
    return config


def dir_to_info(solution_dir):
    """ Load solution configurations from toml file
    """
    config = _get_config(solution_dir)
    if config.get('listed_only', False):
        return process_config(config)
    for solution_fname in glob(pjoin(solution_dir, '*.py')):
        name = basename(splitext(solution_fname)[0])
        if not name in config['solution']:
            config['solution'][name] = {}
    return process_config(config)


def find_solution_dirs(root_dir):
    """ Find directories with matching filenames, or with TOML file
    """
    soln_dirs = set()
    for dirpath, dirnames, filenames in os.walk(root_dir):
        for dn in dirnames:
            if dn in SOLUTION_DIRNAMES:
                soln_dirs.add(pjoin(dirpath, dn))
        for fn in filenames:
            if fn in TOML_FNAMES:
                soln_dirs.add(dirpath)
    return [realpath(d) for d in sorted(soln_dirs)]


def get_solution_infos(root_dir):
    """ Return solution information dictionaries for input path `root_dir`
    """
    solution_infos = []
    for solution_dir in find_solution_dirs(root_dir):
        solution_infos.append(dir_to_info(solution_dir))
    return solution_infos


def process_solution(solution_contents):
    exercise_contents = []
    state = None
    for line in solution_contents.splitlines(True):
        sline = line.strip()
        if re.match(r"#+ LAB\(begin solution\)", sline):
            state = 'solution'
        elif re.match(r"#+ LAB\(replace solution\)", sline):
            state = 'replace'
        elif re.match(r"#+ LAB\(end solution\)", sline):
            state = None
        elif state != 'solution':
            if state == 'replace':
                line = re.sub(r"#\s*", '', line)
            exercise_contents.append(line)
    return ''.join(exercise_contents)


def write_exercise(solution_fname, exercise_fname, processor=process_solution):
    with open(solution_fname, 'rt') as fobj:
        solution = fobj.read()
    exercise = processor(solution)
    with open(exercise_fname, 'wt') as fobj:
        fobj.write(exercise)


def rewrite_exercise(info, processor=process_solution):
    if not info.get('skip_write', False):
        write_exercise(info['in_path'], info['out_path'], processor)


def check_solution(info):
    print('Checking ' + info['in_path'])
    for check in info['checks']:
        check_call(check['command'], cwd=check['cwd'])


def get_parser():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('command', default='check', nargs='?',
                        help='one of {check, write}, default: check')
    parser.add_argument('start_path', default=os.getcwd(), nargs='?',
                        help='exercise directory (default: current directory)')
    return parser


def main():
    args = get_parser().parse_args()
    command, start_path = args.command, args.start_path
    solution_sets = get_solution_infos(start_path)
    if command == 'write':
        for infos in solution_sets:
            for name, info in infos['solution'].items():
                rewrite_exercise(info)
    elif command == 'write-solutions':
        print("Warning - writing solutions over exercises")
        for infos in solution_sets:
            for name, info in infos['solution'].items():
                rewrite_exercise(info, lambda txt : txt)
        print("Warning - run 'write' to write exercises")
    elif command == 'check':
        for infos in solution_sets:
            for name, info in infos['solution'].items():
                check_solution(info)
    else:
        raise RuntimeError('Invalid command ' + command)


if __name__ == '__main__':
    main()
